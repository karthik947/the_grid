@startuml flow
title The Grid - runtime + data flow
left to right direction
allow_mixing
skinparam classAttributeIconSize 0

actor User
actor "Binance WS" as BWS
actor "Binance REST" as BREST

package "UI (eframe/egui)" {
  class DashboardApp {
    +rx: UiRx
    +settings: SettingsForm
    +preset_store: PresetStore
    +activate_preset(label)
    +render_dashboard(...)
  }
  class SettingsForm {
    +pairs_input: String
    +volatility_enabled: bool
    +volatility_timeframes: BTreeMap<Timeframe, VolatilityTimeframeSetting>
    +rsi_enabled: bool
    +rsi_length: usize
    +rsi_source: KlineSource
    +rsi_timeframes: BTreeMap<Timeframe, bool>
    +pairs() -> Vec<String>
    +indicator_config() -> Vec<IndicatorConfig>
  }
  class PresetStore {
    +load()/save()
    +labels() -> Vec<String>
    +upsert(label, settings)
    +get(label)
  }
}

package "Config / Types" {
  class AppConfig {
    +pairs(): &[String]
    +indicators(): IndicatorConfig
    +index_lookup(): IndexLookup
    +from_settings(SettingsForm)
  }
  class IndicatorConfig {
    +volatility: VolatilityConfig
    +rsi: RsiConfig
  }
  class VolatilityConfig {
    +enabled(): bool
    +timeframes(): &[Timeframe]
  }
  class RsiConfig {
    +enabled(): bool
    +length(): usize
    +source(): KlineSource
    +timeframes(): &[Timeframe]
  }
  class IndexLookup {
    +index(pair, indicator, timeframe) -> Option<usize>
    +pair_stride(): usize
    +pair_count(): usize
  }
  enum Timeframe {
    M1
    M5
    M15
    M30
    H1
    H4
    D1
  }
  enum IndicatorKey {
    Volatility
    Rsi
  }
  enum IndicatorValue {
    Volatility
    Rsi
  }
  enum KlineSource {
    Open
    High
    Low
    Close
  }
}

package "Message buses (mpsc)" {
  class EngineBus {
    +engine_sender
    +into_engine
  }
  class HistoryBus {
    +history_sender
    +into_engine
  }
  class WsBus {
    +ws_sender
    +into_engine
  }
  class UiBus {
    +ui_sender
    +into_engine
  }
  enum EngineMessage {
    Kline
    Reboot
    KHistBundle
    Config
  }
  enum HistoryMessage {
    WarmUp
    Config
  }
  enum WsMessage {
    Config
  }
  enum UiMessage {
    IndicatorResults
  }
}

package "Runtime services (tokio tasks)" {
  class Engine {
    -config: Option<AppConfig>
    -indicators: IndicatorManager
    -warmup_pending: Option<HashSet<Pair>>
    -warmup_done: bool
    -flush_interval: Interval
    +run()
    +handle_kline(...)
    +handle_reboot(...)
    +flush_indicator_results()
  }
  class IndicatorManager {
    +update(pair, tf, indicator, bar_1m) -> IndicatorResult
    +update_khist(KlineHist)
  }
  class HistoryService {
    -config: Option<AppConfig>
    +run()
  }
  class WsClient {
    -config: Option<AppConfig>
    +run()
    +update_config(AppConfig)
  }
}

package "Adapters" {
  class BinanceRest {
    +kline_history
  }
  class KlineStore {
    +init
  }
}

User --> DashboardApp : interact\nupdate presets/settings
DashboardApp --> AppConfig : build config
DashboardApp --> EngineBus : send Config
DashboardApp --> HistoryBus : send Config
DashboardApp --> WsBus : send Config
UiBus --> DashboardApp : IndicatorResults\n(batch repaint)

BWS --> WsClient : multiplexed klines
WsClient --> EngineBus : Kline / Reboot
WsClient --> WsBus : listens for Config

EngineBus --> Engine : Kline / Reboot / Config / KHistBundle
Engine --> UiBus : IndicatorResults (batched)
Engine --> HistoryBus : WarmUpEvent (per pair after reboot)
Engine ..> IndicatorManager

HistoryBus --> HistoryService : WarmUp / Config
HistoryService --> KlineStore : fetch history (async)
KlineStore --> BinanceRest
BinanceRest --> BREST : REST klines
HistoryService --> EngineBus : KHistBundle (seed indicators)

note bottom of Engine
  Flow after config:
  - reset indicator state; mark pairs pending warmup
  - live klines gated until warmup sent
  - per-indicator/timeframe values buffered
  - flush to UI roughly every 2s
end note

note bottom of DashboardApp
  UI uses IndexLookup slots from AppConfig
  to render pair x timeframe tables with
  threshold-aware coloring and size presets.
end note

@enduml
